using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Validly.SourceGenerator.Builders;
using Validly.SourceGenerator.Dtos;
using Validly.SourceGenerator.Utils;
using Validly.SourceGenerator.Utils.Mapping;
using Validly.SourceGenerator.Utils.SourceTexts;
using Validly.SourceGenerator.Utils.SourceTexts.FileBuilders;
using Validly.SourceGenerator.ValueProviders;

namespace Validly.SourceGenerator;

[Generator]
public class ValidatableSourceGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext initContext)
	{
		var allValidators = ValidatorsIncrementalValueProvider.Get(initContext);
		var validatableObjects = ValidatableObjectIncrementalValueProvider.Get(initContext);
		var config = ConfigOptionsProvider.Get(initContext);

		initContext.RegisterSourceOutput(
			validatableObjects
				.Combine(config)
				.Combine(allValidators)
				.Select((tuple, _) => (tuple.Left.Left, tuple.Left.Right, tuple.Right)),
			ExecuteValidatorGeneration
		);
	}

	private static void ExecuteValidatorGeneration(
		SourceProductionContext context,
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties
	)
	{
		var methods = properties
			.Object.Methods.GroupBy(x => x.MethodName)
			.ToDictionary(x => x.Key, group => group.First());

		// Name of the class with RULEs
		string rulesClassName = $"{properties.Object.Name}Rules";
		string customValidatorInterfaceName = $"I{properties.Object.Name}CustomValidation";

		var dependencies = new DependenciesTracker();
		AppendDependenciesOfBeforeAndAfterMethods(properties.Object, dependencies);

		// Builders
		var rulesClassBuilder = new RulesClassBuilder(rulesClassName);
		var customValidationsInterfaceBuilder = new CustomValidationInterfaceBuilder(
			customValidatorInterfaceName,
			dependencies
		).WithMethods(methods);
		var invocationBuilder = new PropertiesValidationInvocationBuilder(
			rulesClassName,
			dependencies,
			properties.Object.ExitEarly ?? properties.Config.ExitEarly
		);

		// Generate stuff for each property
		foreach (PropertyProperties property in properties.Object.Properties)
		{
			var attributes = ToAttributeList(properties, property);

			// Skip properties without validators
			if (attributes.Count == 0)
			{
				continue;
			}

			ProcessValidatableProperty(
				property,
				properties.Object,
				properties.Validators,
				attributes,
				rulesClassBuilder,
				customValidationsInterfaceBuilder,
				invocationBuilder
			);
		}

		bool isAsync =
			customValidationsInterfaceBuilder.Calls.AnyAsync()
			|| invocationBuilder.Calls.AnyAsync()
			|| (
				(properties.Object.BeforeValidateMethod?.ReturnTypeType ?? ReturnTypeType.None)
				& ReturnTypeType.Awaitable
			) != 0
			|| (
				(properties.Object.AfterValidateMethod?.ReturnTypeType ?? ReturnTypeType.None)
				& ReturnTypeType.Awaitable
			) != 0
			// TODO: Can we handle this differently? How should we check if that type is async validator? For now, we force async behavior if there is any property of Validatable type
			|| properties.Object.Properties.Any(prop => prop.PropertyIsOfValidatableType)
			// TODO: Like above, we force async behavior if the object inherits from Validatable object
			|| properties.Object.InheritsValidatableObject;

		// Generate the validator part for the original object
		// > public partial class Xxx : IValidatable, IInternalValidationInvoker { ... }
		var validatorClassBuilder = DeclarationBuilder
			.CreateClassOrRecord(properties.Object.ClassOrRecordKeyword, properties.Object.Name)
			.SetAccessModifier(properties.Object.Accessibility)
			.AddUsings(properties.Object.Usings.GetArray() ?? Array.Empty<string>())
			// .SetNamespace(properties.Object.Namespace)
			.Partial()
			.AddInterfaces(Consts.IValidatableGlobalRef)
			.AddInterfaces(Consts.InternalValidationInvokerGlobalRef)
			.AddMember(CreateImplementationOfInternalValidationInvoker())
			.AddMember(CreateIValidatableValidateMethod(dependencies))
			.AddMemberIf(CreateSyncValidateMethod(properties, dependencies, isAsync), !isAsync)
			.AddMember(
				CreateValidateMethod(
					properties,
					dependencies,
					customValidationsInterfaceBuilder.HasAnyMethod(),
					customValidatorInterfaceName,
					invocationBuilder,
					isAsync
				)
			);

		// If custom validation is used, add generated interface to the validator class
		if (customValidationsInterfaceBuilder.HasAnyMethod())
		{
			// Add the interface on validator part of the original object
			validatorClassBuilder.AddInterfaces(customValidatorInterfaceName);
		}

		var sourceText =
			"// <auto-generated/>"
			+ Environment.NewLine
			+ "#nullable enable"
			+ Environment.NewLine
			+ Environment.NewLine
			+ (
				properties.Object.Namespace is null
					? string.Empty
					: $"namespace {properties.Object.Namespace}{Environment.NewLine}{{{Environment.NewLine}"
			)
			+ validatorClassBuilder.Build().Indent()
			+ Environment.NewLine
			+ rulesClassBuilder.Build().Indent()
			+ Environment.NewLine
			+ customValidationsInterfaceBuilder.Build().Indent()
			+ Environment.NewLine
			+ (properties.Object.Namespace is null ? string.Empty : "}");

		context.AddSource($"{properties.Object.Name}.Validator.g.cs", SourceText.From(sourceText, Encoding.UTF8));
	}

	private static void AppendDependenciesOfBeforeAndAfterMethods(
		ObjectProperties objectProperties,
		DependenciesTracker dependencies
	)
	{
		if (objectProperties.BeforeValidateMethod is not null)
		{
			foreach (var dependency in objectProperties.BeforeValidateMethod.Dependencies)
			{
				dependencies.AddDependency(dependency);
			}
		}

		if (objectProperties.AfterValidateMethod is not null)
		{
			foreach (var dependency in objectProperties.AfterValidateMethod.Dependencies)
			{
				dependencies.AddDependency(dependency);
			}
		}
	}

	/// <summary>
	/// Create list of validation attributes. Include auto validators if enabled.
	/// </summary>
	/// <param name="properties"></param>
	/// <param name="property"></param>
	/// <returns></returns>
	private static List<AttributeProperties> ToAttributeList(
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties,
		PropertyProperties property
	)
	{
		var attributes = property.Attributes.GetArray()?.ToList() ?? new List<AttributeProperties>();

		// Add automatic validators
		AddAutoValidators(attributes, property, properties.Config, properties.Object.UseAutoValidators);

		return attributes;
	}

	private static SourceTextSectionBuilder CreateValidateMethod(
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties,
		DependenciesTracker dependencies,
		bool hasCustomValidation,
		string customValidatorInterfaceName,
		PropertiesValidationInvocationBuilder invocationBuilder,
		bool isAsync
	)
	{
		var asyncKeyword = isAsync ? "async" : string.Empty;
		var overrideVirtual = properties.Object.InheritsValidatableObject ? "override" : "virtual";
		var serviceProviderParameter = dependencies.HasDependencies
			? $"{Consts.ServiceProviderGlobalRef} serviceProvider"
			: string.Empty;
		var cancellationTokenParameter = dependencies.HasDependencies
			? ", CancellationToken ct = default"
			: "CancellationToken ct = default";
		var serviceProviderDep = dependencies.HasDependencies ? "serviceProvider" : "null";

		var validateMethodFilePart = new SourceTextSectionBuilder()
			// .AppendLine("#if NET7_0_OR_GREATER")
			// .AppendLine(
			// 	"[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]"
			// )
			// .AppendLine("#endif")
			.AppendLine(
				$$"""

				/// <summary>
				/// Validate the object and get the result with error messages.
				/// </summary>
				/// <returns>Returns disposable ValidationResult.</returns>
				public {{overrideVirtual}} {{asyncKeyword}} ValueTask<{{Consts.ValidationResultGlobalRef}}> ValidateAsync({{serviceProviderParameter}}{{cancellationTokenParameter}})
				{
					{{Consts.InternalValidationResultGlobalRef}}? result = null;
					var contextSet = (({{Consts.InternalValidationInvokerGlobalRef}})this).GetValidationContext();
					var context = contextSet == null
						? {{Consts.ValidationContextGlobalRef}}.Create(this)
						: contextSet;

					// Ensure disposal of ValidationContext if it was created here
					using var _ = new {{Consts.ValidationContextDisposerGlobalRef}}(context, contextSet == null);

					try {
				"""
			)
			// .AppendLine("\ttry {")
			.AppendLineIf($"\t\tvar customValidator = ({customValidatorInterfaceName})this;", hasCustomValidation);

		var nestedValidations = new List<string>();
		var nestedValidationsDispose = new List<string>();

		foreach (var property in properties.Object.Properties)
		{
			if (!property.PropertyIsOfValidatableType)
			{
				continue;
			}

			nestedValidations.Add(
				$"""
				context.SetObject(this.{property.PropertyName});
				(({Consts.InternalValidationInvokerGlobalRef})this.{property.PropertyName}).SetValidationContext(context);
				#pragma warning disable CS8625
				var nestedValidationResult{nestedValidationsDispose.Count} = await (({Consts.IValidatableGlobalRef})this.{property.PropertyName}).ValidateAsync({serviceProviderDep}, ct);
				#pragma warning restore CS8625
				nestedPropertiesCount += (({Consts.InternalValidationResultGlobalRef})nestedValidationResult{nestedValidationsDispose.Count}).GetPropertiesCount();
				"""
			);

			nestedValidationsDispose.Add(
				$"""
				result.CombineNested(nestedValidationResult{nestedValidationsDispose.Count}, "{property.PropertyName}");
				nestedValidationResult{nestedValidationsDispose.Count}.Dispose();
				"""
			);
		}

		var hasNestedProperties = nestedValidations.Count != 0 || properties.Object.InheritsValidatableObject;
		int indentation = 2;

		if (hasNestedProperties)
		{
			validateMethodFilePart
			// .AppendLineIf(
			// 	$"\t\t{Consts.ServiceProviderGlobalRef}? serviceProvider = null;",
			// 	!dependencies.HasDependencies
			// )
			.AppendLine("\t\tvar nestedPropertiesCount = 0;");

			if (nestedValidations.Count != 0)
			{
				validateMethodFilePart.AppendLine(
					$"""

					{string.Join(Environment.NewLine, nestedValidations)}
					context.SetObject(this);

					""".Indent(2)
				);
			}

			if (properties.Object.InheritsValidatableObject)
			{
				// Increate indentation because of try-finally block
				indentation++;

				validateMethodFilePart.AppendLine(
					$$"""

					// call BASE class' Validate()
					(({{Consts.InternalValidationInvokerGlobalRef}})base).SetValidationContext(context);
					using (var baseResult = await base.ValidateAsync({{(
						dependencies.HasDependencies ? "serviceProvider, " : string.Empty
					)}}ct)) {
						nestedPropertiesCount += (({{Consts.InternalValidationResultGlobalRef}})baseResult).GetPropertiesCount();
					""".Indent(2)
				);
			}
		}

		validateMethodFilePart.AppendLine(
			$"result = ({Consts.InternalValidationResultGlobalRef}){Consts.ExtendableValidationResultGlobalRef}.Create({
				properties.Object.Properties.Count}{(hasNestedProperties ? " + nestedPropertiesCount" : string.Empty)
			});".Indent(
				indentation
			)
		);

		if (nestedValidations.Count != 0)
		{
			validateMethodFilePart.AppendLine(
				$"""

				// Dispose nested validation results
				{string.Join(Environment.NewLine, nestedValidationsDispose)}
				""".Indent(indentation)
			);
		}

		if (properties.Object.InheritsValidatableObject)
		{
			// Decrease indentation because of try-finally block end
			indentation--;

			validateMethodFilePart.AppendLine(
				"""
					result.Combine(baseResult);
				}

				""".Indent(2)
			);
		}

		// Prepared for case when users require "ValidationContext" or "ValidationResult" in their custom methods; unused otherwise
		validateMethodFilePart
			.AppendLine("\t\tvar serviceCancellationToken = ct;")
			.AppendLine("\t\tvar serviceValidationContext = context;")
			.AppendLine($"\t\tvar serviceValidationResult = ({Consts.ValidationResultGlobalRef})result;");

		if (dependencies.HasDependencies)
		{
			validateMethodFilePart.AppendLine("\t\t// Required services");

			// for indentation purposes
			foreach (var dependency in dependencies.Services)
			{
				var serviceProviderString = dependency is KeyedDependencyInjectionInfo keyedDependency
					? $"ServiceProviderHelper.GetRequiredKeyedService<{keyedDependency.Name}>(serviceProvider, {keyedDependency.KeySyntax});"
					: $"ServiceProviderHelper.GetRequiredService<{dependency.Name}>(serviceProvider);";

				validateMethodFilePart.AppendLine($"\t\tvar service{dependency.Name} = {serviceProviderString}");
			}
		}

		// BeforeValidate hook
		validateMethodFilePart.AppendLine(
			CreateBeforeOrAfterValidateHook(properties.Object.BeforeValidateMethod).Indent(2)
		);

		// Add INVOCATIONS
		validateMethodFilePart.AppendLine(invocationBuilder.Build().Indent(2));

		// AfterValidate hook
		validateMethodFilePart.AppendLine(
			CreateBeforeOrAfterValidateHook(properties.Object.AfterValidateMethod).Indent(2)
		);

		validateMethodFilePart.AppendLine(
			$$"""
			}
			catch (Exception)
			{
				if (result != null)
				{
					(({{Consts.ValidationResultGlobalRef}})result).Dispose();
				}

				throw;
			}

			""".Indent()
		);

		validateMethodFilePart.AppendLine(
			isAsync
				? $"\treturn ({Consts.ValidationResultGlobalRef})result;"
				: $"\treturn new ValueTask<{Consts.ValidationResultGlobalRef}>(({Consts.ValidationResultGlobalRef})result);"
		);

		validateMethodFilePart.AppendLine("}");

		return validateMethodFilePart;
	}

	/// <summary>
	/// Generate synchronous Validate() method
	/// </summary>
	/// <param name="properties"></param>
	/// <param name="dependencies"></param>
	/// <param name="isAsync"></param>
	/// <returns></returns>
	private static SourceTextSectionBuilder CreateSyncValidateMethod(
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties,
		DependenciesTracker dependencies,
		bool isAsync
	)
	{
		var validateReturnType = isAsync
			? $"ValueTask<{Consts.ValidationResultGlobalRef}>"
			: Consts.ValidationResultGlobalRef;
		var overrideVirtual = properties.Object.InheritsValidatableObject ? "override" : "virtual";
		var serviceProviderParameter = dependencies.HasDependencies
			? $"{Consts.ServiceProviderGlobalRef} serviceProvider"
			: string.Empty;
		var serviceProviderDep = dependencies.HasDependencies ? "serviceProvider" : string.Empty;
		var cancellationTokenDep = dependencies.HasDependencies ? ", default" : "default";

		var validateMethodFilePart = new SourceTextSectionBuilder().AppendLine(
			$$"""

			/// <summary>
			/// Validate the object and get the result with error messages.
			/// </summary>
			/// <returns>Returns disposable ValidationResult.</returns>
			public {{overrideVirtual}} {{validateReturnType}} Validate({{serviceProviderParameter}})
			{
				var task = ValidateAsync({{serviceProviderDep}}{{cancellationTokenDep}});

				if (!task.IsCompletedSuccessfully)
				{
					#if NET7_0_OR_GREATER
					throw new global::System.Diagnostics.UnreachableException("The task should be completed synchronously but was not.");
					#else
					throw new global::System.InvalidOperationException("The task should be completed synchronously but was not.");
					#endif
				}

				return task.Result;
			}
			"""
		);

		return validateMethodFilePart;
	}

	/// <summary>
	/// Generate explicit implementation IValidatable.ValidateAsync() method
	/// </summary>
	/// <param name="dependencies"></param>
	/// <returns></returns>
	private static SourceTextSectionBuilder CreateIValidatableValidateMethod(DependenciesTracker dependencies)
	{
		var serviceProviderParameter = dependencies.HasDependencies
			? $"{Consts.ServiceProviderGlobalRef} serviceProvider"
			: $"{Consts.ServiceProviderGlobalRef} _";
		var serviceProviderDep = dependencies.HasDependencies ? "serviceProvider, " : string.Empty;

		var validateMethodFilePart = new SourceTextSectionBuilder().AppendLine(
			$$"""

			/// <inheritdoc />
			async ValueTask<{{Consts.ValidationResultGlobalRef}}> {{Consts.IValidatableGlobalRef}}.ValidateAsync({{serviceProviderParameter}}, CancellationToken ct)
			{
				return await ValidateAsync({{serviceProviderDep}}ct);
			}
			"""
		);

		return validateMethodFilePart;
	}

	/// <summary>
	/// Generate explicit implementation of InternalValidationInvoker interface
	/// </summary>
	/// <returns></returns>
	private static SourceTextSectionBuilder CreateImplementationOfInternalValidationInvoker()
	{
		var validateMethodFilePart = new SourceTextSectionBuilder().AppendLine(
			$$"""

			private {{Consts.WeakReferenceGlobalRef}}<{{Consts.ValidationContextGlobalRef}}>? _validationContext;

			/// <inheritdoc />
			void {{Consts.InternalValidationInvokerGlobalRef}}.SetValidationContext({{Consts.ValidationContextGlobalRef}} validationContext)
			{
				this._validationContext = new {{Consts.WeakReferenceGlobalRef}}<{{Consts.ValidationContextGlobalRef}}>(validationContext, false);
			}

			/// <inheritdoc />
			{{Consts.ValidationContextGlobalRef}}? {{Consts.InternalValidationInvokerGlobalRef}}.GetValidationContext()
			{
				if (this._validationContext == null)
				{
					return null;
				}

				return this._validationContext.TryGetTarget(out var existingContext)
					? existingContext
					: throw new global::System.InvalidOperationException("ValidationContext has not been set. This is an internal error.");
			}
			"""
		);

		return validateMethodFilePart;
	}

	private static string CreateBeforeOrAfterValidateHook(MethodProperties? method)
	{
		if (method is null)
		{
			return string.Empty;
		}

		var arguments = string.Join(", ", method.Dependencies.Select(dependency => $"service{dependency.Name}"));

		if ((method.ReturnTypeType & ReturnTypeType.Void) != 0)
		{
			if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
			{
				return $"""

					// Call {method.MethodName} hook
					await {method.MethodName}({arguments});
					""";
			}

			return $"""

				// Call {method.MethodName} hook
				{method.MethodName}({arguments});
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.ValidationResult) != 0)
		{
			if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
			{
				return $"""

					// Call {method.MethodName} hook
					var resultOf{method.MethodName} = await {method.MethodName}({arguments});
					if (resultOf{method.MethodName} is not null) return resultOf{method.MethodName};
					""";
			}

			return $"""

				// Call {method.MethodName} hook
				var resultOf{method.MethodName} = {method.MethodName}({arguments});
				if (resultOf{method.MethodName} is not null) return new ValueTask<{Consts.ValidationResultGlobalRef}>(resultOf{method.MethodName});
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.AsyncEnumerable) != 0)
		{
			return $"""

				// Call {method.MethodName} hook
				await result.AddAsync({method.MethodName}({arguments}));
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
		{
			return $"""

				// Call {method.MethodName} hook
				result.Add(await {method.MethodName}({arguments}));
				""";
		}

		return $"""

			// Call {method.MethodName} hook
			result.Add({method.MethodName}({arguments}));
			""";
	}

	private static void ProcessValidatableProperty(
		PropertyProperties validatableProperty,
		ObjectProperties propertiesObject,
		EquatableArray<ValidatorProperties> validators,
		List<AttributeProperties> attributes,
		RulesClassBuilder rulesClassBuilder,
		CustomValidationInterfaceBuilder customValidationInterfaceBuilder,
		PropertiesValidationInvocationBuilder invocationBuilder
	)
	{
		var attributesWithValidators = new List<(AttributeProperties, ValidatorProperties)>(attributes.Count);
		var propertyCalls = new CallsCollection();

		foreach (var validationAttribute in attributes)
		{
			// CUSTOM validation
			if (validationAttribute.QualifiedName == Consts.CustomValidationAttribute)
			{
				customValidationInterfaceBuilder.AddCustomValidationForProperty(validatableProperty, propertyCalls);
				continue;
			}

			var validator = validators.FirstOrDefault(validator =>
				validator.QualifiedName == validationAttribute.QualifiedName
			);

			if (validator is null)
			{
				continue;
			}

			attributesWithValidators.Add((validationAttribute, validator));
		}

		// Generate RULE
		rulesClassBuilder.AddRuleForProperty(validatableProperty, attributesWithValidators);

		bool anyAsync =
			customValidationInterfaceBuilder.Calls.AnyAsync()
			|| (propertiesObject.BeforeValidateMethod?.ReturnTypeType & ReturnTypeType.Awaitable) != 0
			|| (propertiesObject.AfterValidateMethod?.ReturnTypeType & ReturnTypeType.Awaitable) != 0;

		// Generate INVOCATION
		invocationBuilder.AddInvocationForProperty(
			validatableProperty,
			attributesWithValidators,
			propertyCalls,
			anyAsync
		);
	}

	private static void AddAutoValidators(
		List<AttributeProperties> attributes,
		PropertyProperties validatableProperty,
		ValidlyConfiguration config,
		bool? useAutoValidators
	)
	{
		// Auto validators are disabled for this object, or it's a record's "EqualityContract" property
		if (useAutoValidators == false || validatableProperty.PropertyName == "EqualityContract")
		{
			return;
		}

		// Required - Add Required validator if the property is not nullable
		if (
			(useAutoValidators ?? config.AutoRequired)
			&& !validatableProperty.Nullable
			&& attributes.All(x => x.QualifiedName != Consts.RequiredAttributeQualifiedName)
			&& validatableProperty.PropertyTypeKind is not TypeKind.Enum and not TypeKind.Struct
		)
		{
			attributes.Add(AttributeProperties.Required);
		}

		// InEnum - Add InEnum validator for Enum properties
		if (
			(useAutoValidators ?? config.AutoInEnum)
			&& validatableProperty.PropertyTypeKind == TypeKind.Enum
			&& attributes.All(x => x.QualifiedName != Consts.InEnumAttributeQualifiedName)
		)
		{
			attributes.Add(AttributeProperties.InEnum);
		}
	}
}
