using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Valigator.SourceGenerator.Utils;
using Valigator.SourceGenerator.Utils.FileBuilders;
using Valigator.SourceGenerator.Utils.Mapping;
using Valigator.SourceGenerator.Validatables.Dtos;
using Valigator.SourceGenerator.Validatables.ValueProviders;

namespace Valigator.SourceGenerator.Validatables;

[Generator]
public class ValidatableSourceGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext initContext)
	{
		var allValidators = ValidatorsIncrementalValueProvider.Get(initContext);
		var validatableObjects = ValidatableObjectIncrementalValueProvider.Get(initContext);

		initContext.RegisterSourceOutput(validatableObjects.Combine(allValidators), ExecuteValidatorGeneration);
	}

	private static void ExecuteValidatorGeneration(
		SourceProductionContext context,
		(ObjectProperties Object, EquatableArray<ValidatorProperties> Validators) properties
	)
	{
		bool hasCustomValidation = false;
		bool isAsync = properties.Object.Methods.Any(m => m.IsAsync);
		string customValidationInterfaceSourceText = string.Empty;

		var validatorRules = new FilePart();
		var ruleValidateCalls = new List<string>();
		var customValidationMethodsForInterface = new FilePart();
		var dependencies = new HashSet<string>();
		var methods = properties.Object.Methods.ToDictionary(x => x.MethodName, x => x);

		// Name of the class with RULEs
		string rulesClassName = $"{properties.Object.Name}Rules";
		string customValidatorInterfaceName = $"I{properties.Object.Name}CustomValidation";

		// Generate stuff for each property
		foreach (ValidatablePropertyProperties property in properties.Object.Properties)
		{
			ProcessValidatableProperty(
				property,
				properties.Validators,
				methods,
				dependencies,
				validatorRules,
				ruleValidateCalls,
				customValidationMethodsForInterface,
				rulesClassName,
				ref hasCustomValidation,
				ref isAsync
			);
		}

		// Generate the validator part for the original object
		// > public partial class Xxx : IValidatable, IInternalValidationInvoker { ... }
		var validatorClassBuilder = SourceTextBuilder
			.CreateClassOrRecord(properties.Object.ClassOrRecordKeyword, properties.Object.Name)
			.AddUsings(properties.Object.Usings.GetArray() ?? [])
			.SetNamespace(properties.Object.Namespace)
			.Partial()
			.AddInterfaces(Consts.IValidatableGlobalRef)
			.AddInterfaces(Consts.InternalValidationInvokerGlobalRef)
			.AddMember(
				CreateValidateMethod(
					properties,
					dependencies,
					hasCustomValidation,
					customValidatorInterfaceName,
					ruleValidateCalls,
					isAsync
				)
			);

		// If custom validation is used, generate the interface and add it to the validator class
		// > internal interface IXxxCustomValidation { ... }
		if (hasCustomValidation)
		{
			var customValidationInterface = SourceTextBuilder
				.CreateInterface(customValidatorInterfaceName)
				.SetAccessModifier("internal")
				.SetNamespace(properties.Object.Namespace)
				.AddMember(customValidationMethodsForInterface);

			// Add the interface on validator part of the original object
			validatorClassBuilder.AddInterfaces(customValidatorInterfaceName);

			customValidationInterfaceSourceText = customValidationInterface.Build();
		}

		// Create separated class with rules; so it's not visible in the original object
		// > file class XxxRules { ... }
		var validatorRulesClassBuilder = CreateValidatorRulesClassBuilder(
			properties.Object,
			rulesClassName,
			validatorRules
		);

		var validator =
			"// <auto-generated/>"
			+ Environment.NewLine
			+ "# nullable enable"
			+ Environment.NewLine
			+ Environment.NewLine
			+ validatorClassBuilder.Build()
			+ validatorRulesClassBuilder.Build()
			+ customValidationInterfaceSourceText;

		context.AddSource($"{properties.Object.Name}.Validator.g.cs", SourceText.From(validator, Encoding.UTF8));
	}

	private static FilePart CreateValidateMethod(
		(ObjectProperties Object, EquatableArray<ValidatorProperties> Validators) properties,
		HashSet<string> dependencies,
		bool hasCustomValidation,
		string customValidatorInterfaceName,
		List<string> ruleValidateCalls,
		bool isAsync
	)
	{
		var asyncKeyword = isAsync ? "async " : string.Empty;
		var validateReturnType = isAsync
			? $"ValueTask<{Consts.ValidationResultGlobalRef}>"
			: Consts.ValidationResultGlobalRef;
		var overrideVirtual = properties.Object.InheritsValidatableObject ? "override" : "virtual";

		var validateMethodFilePart = new FilePart()
			.AppendLine("/// <inheritdoc />")
			.Append($"ValueTask<{Consts.ValidationResultGlobalRef}>")
			.AppendLine($" {Consts.InternalValidationInvokerGlobalRef}.Validate(")
			.AppendLine($"\t{Consts.ValidationContextGlobalRef} context,")
			.AppendLine($"\t{Consts.ServiceProviderGlobalRef}? serviceProvider")
			.AppendLine(")")
			.AppendLine("{");

		if (hasCustomValidation)
		{
			validateMethodFilePart
				.AppendLine($"\tvar customValidator = ({customValidatorInterfaceName})this;")
				.AppendLine();
		}

		// string globalMessages = "[]";
		validateMethodFilePart.AppendLine(
			$"\tvar result = new {Consts.ExtendableValidationResultGlobalRef}({properties.Object.Properties.Count});"
		);

		if (properties.Object.InheritsValidatableObject)
		{
			// TODO: Support async
			validateMethodFilePart
				.AppendLine("\t// call BASE class' Validate()")
				.AppendLine(
					$"\tvar baseResult = (({Consts.InternalValidationInvokerGlobalRef})base).Validate(validationContext, serviceProvider).Result;"
				)
				.AppendLine("\tresult.AddGlobalMessages(baseResult.Global);")
				.AppendLine();
		}

		if (dependencies.Count > 0)
		{
			validateMethodFilePart
				.AppendLine("\t// Required services")
				.AppendLine("\tvar serviceValidationContext = context;")
				.AppendLine(
					string.Join(
						Environment.NewLine,
						dependencies.Select(dependency =>
							$"\tvar service{dependency} = serviceProvider!.GetRequiredService<{dependency}>();"
						)
					)
				)
				.AppendLine();
		}

		// BeforeValidate hook
		AppendBeforeValidateHook(properties.Object, validateMethodFilePart, isAsync);

		// TODO: Pro property, které jsou validatable, zavolat Validate() a přidat výsledek do resultu; asi bude potřeba udělat runtime check `prop is IContextValidatable` aj. udělat typy pro každou variantu a za běhu ověřit a obvolat

		// > result.AddPropertyResult
		foreach (string validateCall in ruleValidateCalls)
		{
			validateMethodFilePart.AppendLine(validateCall);
		}

		if (properties.Object.InheritsValidatableObject)
		{
			validateMethodFilePart
				.AppendLine("\tforeach (var baseProp in baseResult.Properties) {")
				.AppendLine("\t\tresult.AddPropertyResult(baseProp);")
				.AppendLine("\t}")
				.AppendLine();
		}

		// AfterValidate hook
		var afterValidateMethodReturns = AppendAfterValidateHook(properties.Object, validateMethodFilePart, isAsync);

		if (!afterValidateMethodReturns)
		{
			validateMethodFilePart.AppendLine(
				isAsync
					? "\treturn result;"
					: $"\treturn ValueTask.FromResult<{Consts.ValidationResultGlobalRef}>(result);"
			);
		}

		validateMethodFilePart.AppendLine("}");

		// Explicit implementation of IValidatable
		validateMethodFilePart
			.AppendLine()
			.AppendLine("/// <inheritdoc />")
			.Append($"ValueTask<{Consts.ValidationResultGlobalRef}>")
			.Append($" {Consts.IValidatableGlobalRef}.Validate(IServiceProvider serviceProvider)")
			.AppendLine("{")
			.AppendLine($"\tusing var validationContext = {Consts.ValidationContextGlobalRef}.Create(this);")
			.AppendLine(
				$"\treturn (({Consts.InternalValidationInvokerGlobalRef})this).Validate(validationContext, serviceProvider);"
			)
			.AppendLine("}");

		var serviceProviderDep = dependencies.Count > 0 ? "serviceProvider" : "null";

		// Validate() method
		validateMethodFilePart
			.AppendLine()
			.AppendLine("/// <summary>Validate the object.</summary>")
			// > public virtual async ValueTask<ValidationResult> Validate(
			.Append($"public {overrideVirtual} {asyncKeyword}{validateReturnType} Validate(")
			.AppendIf($"{Consts.ServiceProviderGlobalRef} serviceProvider", dependencies.Count > 0)
			.AppendLine(")")
			.AppendLine("{")
			.AppendLine($"\tusing var validationContext = {Consts.ValidationContextGlobalRef}.Create(this);")
			.AppendLineIf(
				$"\treturn await (({Consts.InternalValidationInvokerGlobalRef})this).Validate(validationContext, {serviceProviderDep});",
				isAsync
			)
			.AppendLineIf(
				$"\treturn (({Consts.InternalValidationInvokerGlobalRef})this).Validate(validationContext, {serviceProviderDep}).Result;",
				!isAsync
			)
			.AppendLine("}");

		return validateMethodFilePart;
	}

	private static void AppendBeforeValidateHook(
		ObjectProperties objectProperties,
		FilePart validateMethodFilePart,
		bool isAsync
	)
	{
		if (objectProperties.BeforeValidateMethod is null)
		{
			return;
		}

		string awaitKeyword = objectProperties.BeforeValidateMethod.Awaitable ? "await " : string.Empty;

		// VOID
		if (
			objectProperties.BeforeValidateMethod.ReturnType is "void" or "Task"
			&& objectProperties.BeforeValidateMethod.ReturnTypeGenericArgument is null
		)
		{
			validateMethodFilePart
				.AppendLine("// BEFORE Validate()")
				.AppendLine($"\t{awaitKeyword}BeforeValidate();")
				.AppendLine();

			return;
		}

		// ValidationResult
		if (
			objectProperties.BeforeValidateMethod.ReturnType == Consts.ValidationResultName
			|| objectProperties.BeforeValidateMethod.ReturnTypeGenericArgument == Consts.ValidationResultName
		)
		{
			validateMethodFilePart
				.AppendLine("\t// BEFORE Validate()")
				.AppendLine($"\tvar beforeValidate = {awaitKeyword}BeforeValidate();")
				.AppendLine()
				.AppendLine("\tif (beforeValidate is not null)")
				.AppendLineIf("\t\treturn beforeValidate;", isAsync)
				.AppendLineIf("\t\treturn ValueTask.FromResult(beforeValidate);", !isAsync)
				.AppendLine();

			return;
		}

		// IEnumerable | IAsyncEnumerable
		validateMethodFilePart
			.AppendLine("\t// BEFORE Validate()")
			.AppendLine("\tresult.AddGlobalMessages(BeforeValidate())")
			.AppendLine();
	}

	private static bool AppendAfterValidateHook(
		ObjectProperties objectProperties,
		FilePart validateMethodFilePart,
		bool isAsync
	)
	{
		if (objectProperties.AfterValidateMethod is null)
		{
			return false;
		}

		string afterValidateAwaitKeyword = objectProperties.AfterValidateMethod.Awaitable ? "await " : string.Empty;
		string helperAwaitKeyword =
			objectProperties.AfterValidateMethod.ReturnType == "IAsyncEnumerable" ? "await " : string.Empty;

		if (
			objectProperties.AfterValidateMethod.ReturnType is "void" or "Task"
			&& objectProperties.AfterValidateMethod.ReturnTypeGenericArgument is null
		)
		{
			validateMethodFilePart
				.AppendLine("// AFTER Validate()")
				.AppendLine($"\t{afterValidateAwaitKeyword}AfterValidate();")
				.AppendLine();

			return false;
		}

		if (isAsync)
		{
			validateMethodFilePart.AppendLine(
				$"\treturn {helperAwaitKeyword}{Consts.ValidationResultHelperGlobalRef}.ReplaceOrAddMessages(result, {afterValidateAwaitKeyword}AfterValidate(result));"
			);
		}
		else
		{
			validateMethodFilePart.AppendLine(
				$"\treturn ValueTask.FromResult({Consts.ValidationResultHelperGlobalRef}.ReplaceOrAddMessages(result, AfterValidate(result)));"
			);
		}

		return true;
	}

	private static SourceTextBuilder CreateValidatorRulesClassBuilder(
		ObjectProperties objectProperties,
		string rulesClassName,
		FilePart validatorRules
	)
	{
		return SourceTextBuilder
			.CreateClass(rulesClassName)
			.Static()
			.SetAccessModifier("file")
			.SetNamespace(objectProperties.Namespace)
			.AddMember(validatorRules);
	}

	private static void ProcessValidatableProperty(
		ValidatablePropertyProperties validatableProperty,
		EquatableArray<ValidatorProperties> validators,
		Dictionary<string, MethodProperties> methods,
		HashSet<string> dependencies,
		FilePart validatorRulesFilePart,
		List<string> ruleValidateCalls,
		FilePart customValidationMethodsForInterface,
		string rulesClassName,
		ref bool hasCustomValidation,
		ref bool isAsync
	)
	{
		// Skip properties without validators
		if (validatableProperty.ValidationAttributes.Count == 0)
		{
			return;
		}

		bool thisRuleHasCustomValidation = false;
		// bool thisHasContext = false;
		string ruleName = $"{validatableProperty.PropertyName}Rule";

		var tupleTypeArguments = new List<string>();
		var validatorRuleValidatorsLines = new List<string>();
		var enumerableValidatorInvocationValidatorsLines = new List<string>();
		var singleMessageValidatorInvocationValidatorsLines = new List<string>();
		int itemNumber = 1;

		foreach (var validationAttribute in validatableProperty.ValidationAttributes)
		{
			// CUSTOM validation
			if (validationAttribute.QualifiedName == Consts.CustomValidationAttribute)
			{
				thisRuleHasCustomValidation = true;
				hasCustomValidation = true;
				continue;
			}

			var validator = validators.FirstOrDefault(validator =>
				validator.QualifiedName == validationAttribute.QualifiedName
			);

			if (validator is null)
			{
				continue;
			}

			// Check if the method is ASYNC
			if (validator.IsValidMethod.IsAsync)
			{
				isAsync = true;
			}

			// Add dependencies to list (except the ValidationContext)
			foreach (var service in validator.IsValidMethod.Dependencies)
			{
				if (service == Consts.ValidationContextName)
				{
					continue;
				}

				dependencies.Add(service);
			}

			tupleTypeArguments.Add($"\t\t\tglobal::{validator.QualifiedName}");
			validatorRuleValidatorsLines.Add(
				$"\t\t\tnew global::{validator.QualifiedName}({string.Join(", ", validationAttribute.Arguments)})"
			);

			// > XxxRules.NameRule.Item1.IsValid(Xyz, serviceSomeService)
			var args = string.Join(
				", ",
				new[] { validatableProperty.PropertyName }.Concat(
					validator.IsValidMethod.Dependencies.Select(service => $"service{service}")
				)
			);

			var validatorInvocation = $"{rulesClassName}.{ruleName}.Item{itemNumber}.IsValid({args})";

			if (validator.IsValidMethod.ReturnType == Consts.ValidationMessageName)
			{
				singleMessageValidatorInvocationValidatorsLines.Add(validatorInvocation);
			}
			else
			{
				enumerableValidatorInvocationValidatorsLines.Add(validatorInvocation);
			}

			itemNumber++;
		}

		validatorRulesFilePart
			.Append("internal static readonly ValueTuple<" + Environment.NewLine)
			.AppendLine(string.Join(", " + Environment.NewLine, tupleTypeArguments))
			.Append($"> {ruleName} = (")
			.AppendIf(
				$"ValueTuple.Create({validatorRuleValidatorsLines[0].TrimStart()})",
				validatorRuleValidatorsLines.Count == 1
			)
			.AppendLineIf(
				Environment.NewLine + string.Join("," + Environment.NewLine, validatorRuleValidatorsLines),
				validatorRuleValidatorsLines.Count > 1
			)
			.AppendLine(");")
			.AppendLine();

		if (thisRuleHasCustomValidation)
		{
			// Generate CUSTOM validation method to the interface

			if (methods.TryGetValue($"Validate{validatableProperty.PropertyName}", out var existingMethod))
			{
				// Check if the method is ASYNC
				if (existingMethod.IsAsync)
				{
					isAsync = true;
				}

				customValidationMethodsForInterface
					.AppendLine(
						$"/// <summary>Custom validation method for property '{validatableProperty.PropertyName}'.</summary>"
					)
					.Append($"{existingMethod.ReturnType}")
					.AppendIf(
						$"<{existingMethod.ReturnTypeGenericArgument}>",
						existingMethod.ReturnTypeGenericArgument is not null
					)
					.Append($" Validate{validatableProperty.PropertyName}(");

				var customValidationDependencies = new List<string>();

				foreach (string service in existingMethod.Dependencies)
				{
					customValidationDependencies.Add(
						$"{service} {service.Substring(0, 1).ToLower() + service.Substring(1)}"
					);
				}

				customValidationMethodsForInterface.Append(string.Join(", ", customValidationDependencies));

				// Add INVOCATION
				var customValidatorInvocation =
					$"customValidator.Validate{validatableProperty.PropertyName}"
					+ $"({string.Join(", ", existingMethod.Dependencies.Select(service => $"service{service}"))})";

				if (existingMethod.ReturnType == Consts.ValidationMessageName)
				{
					singleMessageValidatorInvocationValidatorsLines.Add(customValidatorInvocation);
				}
				else
				{
					enumerableValidatorInvocationValidatorsLines.Add(customValidatorInvocation);
				}
			}
			else
			{
				customValidationMethodsForInterface
					.AppendLine(
						$"/// <summary>Custom validation method for property '{validatableProperty.PropertyName}'.</summary>"
					)
					.Append($"IEnumerable<ValidationMessage> Validate{validatableProperty.PropertyName}(");

				// Add INVOCATION
				enumerableValidatorInvocationValidatorsLines.Add(
					$"customValidator.Validate{validatableProperty.PropertyName}()"
				);
			}

			customValidationMethodsForInterface.AppendLine(");");
		}

		// Generate INVOCATION `xxRule.IsValid()`
		var validationCalls = new StringBuilder();
		validationCalls.Append(
			@$"	// Validate {validatableProperty.PropertyName}
			context.SetProperty(""{validatableProperty.PropertyName}"");
			result.AddPropertyResult(
				{Consts.PropertyValidationResultGlobalRef}.Create(
					""{validatableProperty.PropertyName}"""
		);

		if (enumerableValidatorInvocationValidatorsLines.Count != 0)
		{
			validationCalls.Append(
				@$",
					{CreateConcatenation(enumerableValidatorInvocationValidatorsLines)}"
			);
		}

		validationCalls.AppendLine(
			@$"
				)
				{CreateAddChain(singleMessageValidatorInvocationValidatorsLines)}
			);"
		);

		ruleValidateCalls.Add(validationCalls.ToString());
	}

	private static string CreateAddChain(List<string> invocations)
	{
		return string.Join(
			Environment.NewLine + "\t\t\t\t",
			invocations.Select(invocation => $".AddValidationMessage({invocation})")
		);
	}

	private static string CreateConcatenation(List<string> enumerators)
	{
		if (enumerators.Count == 0)
		{
			return string.Empty;
		}

		if (enumerators.Count == 1)
		{
			return enumerators[0];
		}

		var builder = new StringBuilder();
		builder.AppendLine(enumerators[0]);

		for (int i = 1; i < enumerators.Count; i++)
		{
			builder.AppendLine($"\t\t\t\t\t\t.Concat({enumerators[i].TrimStart()})");
		}

		return builder.ToString();
	}
}
